


HashTable  --> ConcurrentHashMap


HashTable  刚开始设计的时候只有这个,所有方法都加了锁的 线程是安全的 但是性能不是很高
HashMap    后来意识到之后就把锁都给取消了 , 所有方法都没有加锁  线程不安全  但是性能较高
SynchronizedHashTable 后来觉得锁的粒度放细一点,只在具体调用函数的代码块来锁 其实和HashTable本质上并没什么区别.

ConcurrentHashMap (*多线程) 
采用了跳表的形式虽然写的时候不如 HashTable高 但是读起来性能高很多



Vector --> Queue

Vector 线程安全 大部分关键方法都加了锁 
但是可能出现锁与锁之间的共享问题 还是会出现线程不安全
就是两个方法虽然都加了锁但是 调用过程中会出现问题

List  完全没锁 线程不安全, 需要手动加锁来处理任务

Queue (*高并发,多线程) 内部使用的是CAS来操作数据





ConcurrentHashMap  无序集合 高并发使用 

ConcurrentSkipListMap 有序集合线程安全高并发使用  跳表实现原理 读取效率高


CopyOnWrite  写-时-复制
也就是说 在写的时候复制一份对象  如果一个业务写的业务较少 读取的业务较多的时候 可以考虑用这个， 其本质上来讲就是一个ReadWriteLock

CopyOnWriteList
/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        //重点是这一句话
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

CopyOnWriteSet






ConcurrentQueue
	和Queue 的区别
	offer -> add  会有返回值
	peek -> get 
	poll -> get remove


LinkedBlockQueue
链表实现的阻塞队列 
在ConcurrentQueue基础上添加了方法
	put 如果满了就等待
	take 如果空了就等待
	底层实现是利用了part 和unpart  类似之前面试题用到的 wait notify



DelayQueue
	按照等待时间排序  也是阻塞队列的一种 BlockingQueue
	按照时间进行任务调度可以用这个
	本质上是PriorityQueue



SychronusQueue   同步
	本质上和exchange线程差不多 
	线程size为0  所以不能add 不能往里面装东西 
	会阻塞等待消费者进行消费 
	put
	take


TransferQueue  
	需要得到一个线程完成的标记或者是结果 可以用这个




Synchronized 
	wait  notify  面试重点

notifyAll 是让所有线程都醒过来去争抢锁  




ExecutorServeices ->  Executor   线程池 
	里面拥有很多操作线程的方法 
	awaitTermination
	invokeAll
	invokeAny
	isShutdown
	isTerminated
	shutdown
	shutdownNow
	submit
 
 	ExecutorServeices.submit 之后是异步执行的 不影响主线程

	Callable(String)  一个有返回值的线程

    Future 
    Future<String> submit = executorService.submit(() -> {
            return "";
        });
    submit.get();
    线程池提交一个线程之后会返回这个线程的future 我们可以get它的返回值 提交是异步 get是阻塞的


	FutureTask 用来存放Callable的返回值 --public FutureTask(Callable<V> callable)
	如果想拿到的话 直接调用 FutureTask.get() 这个方法是阻塞的
	相当于直接拿到这个线程的返回值 不需要生成线程池


	CompletableFuture
	组合各个线程的返回结果然后统一返回一个结果 










两种线程池的自定义方式

1. ThreadPoolExecutor -> AbstractExecutorService -> ExecutorService ->  Executor



ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4,
            60, TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(4),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy());

7个参数  
1. 核心线程
2. 可扩展的最大线程
3. keepAliveTime  如果一个线程空闲时间超过设定值则讲线程紫苑交给操作系统 核心线程永远活着
不过有个方法可以设置核心线程参不参与归还资源
4. 时间单位
5. BolckingQueue 
线程队列
ArrayBlockingQueue
当线程满了之后 后续任务进入的等待队列



6. DefaultThreadFactory 线程池的工厂类
实现 ThreadFactory 接口  里面有一个newThread 自己去实现具体的线程
public Thread newThread(Runnable r) {
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);
    if (t.isDaemon())
    //设置线程守护
        t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
    //设置优先级
        t.setPriority(Thread.NORM_PRIORITY);
    return t;
}


7. 拒绝策略 

线程池满了 并且 任务队列也满了 然后启动的非核心线程数也满了  会执行拒绝策略
JDK默认提供了四种拒绝策略 
Abort  抛异常
Discard 扔掉,不抛异常
DiscardOldest 扔掉排队时间最久的
CallerRuns 调用处理任务 哪个线程调用的哪个去处理 非异步处理

我们也可以去自定义自己的拒绝策略


2. ForkJoinPool -> AbstractExecutorService -> ExecutorService ->  Executor
主要用来处理CPU密集型的任务  
	






























JDK默认的线程池的实现

Executors -线程池的工厂

1. SingleThreadExecutor
	
单例的线程 里面只有一个线程
new FinalizableDelegatedExecutorService
(new ThreadPoolExecutor(1, 1,
                        0L, TimeUnit.MILLISECONDS,
                        new LinkedBlockingQueue<Runnable>()));


newCachedThreadPool 
里面拥有核心线程池为0, 可以扩展最大的为int最大值
new ThreadPoolExecutor(0, Integer.MAX_VALUE,
						  60L, TimeUnit.SECONDS,
						  new SynchronousQueue<Runnable>());


newFixedThreadPool 
固定的值 可以通过计算 一般是CPU的核心线程数+1


new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());



newScheduledThreadPool
定时任务线程池
可以用框架代替 
Quartz cron 

super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
      new DelayedWorkQueue());




以上四个线程池底层都是ThreadPoolExecutor来实现的





自定义拒绝策略


static class MyHandler implements RejectedExecutionHandler {

    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        //log("r rejected")
        //save r kafka mysql redis
        //try 3 times
        if(executor.getQueue().size() < 10000) {
            //try put again();
        }
    }
}


















并发和并行 Concurrent VS Parallel

并发指的是任务同时到达某个接口

并行指的是多个CPU同时去处理某个事情


并行是并发的子集











ForkJoinPool
每个线程有自己的任务队列



把大任务切分成一个一个的小任务来执行
然后再汇总结果


newWorkStealingPool
 new ForkJoinPool
(Runtime.getRuntime().availableProcessors(),
 ForkJoinPool.defaultForkJoinWorkerThreadFactory,
 null, true);









Disruptor  纤程
维护一个环形数组队列 首尾相连









































